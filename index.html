<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Solar Wind Archive｜太陽風記憶體</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: "Helvetica Neue", sans-serif;
      }
      #overlay {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        z-index: 10;
      }
      #overlay h1 {
        margin: 0 0 10px;
        font-size: 1.5em;
        color: #ffcc99;
      }
      #overlay p {
        font-size: 0.9em;
        color: #cccccc;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>太陽風記憶體｜Solar Wind Archive</h1>
      <p>🖼️ 請將你的圖像拖曳進畫面<br />在日冕風中，記憶將被釋放</p>
    </div>

    <script>
      // let img;
      // let particles = [];
      // let windLines = [];
      // let windStrength = 0.005;

      // function setup() {
      //   createCanvas(windowWidth, windowHeight);
      //   pixelDensity(1);
      //   imageMode(CENTER);
      //   background(0);
      //   textAlign(CENTER);
      //   textSize(16);
      //   fill(255);
      //   text("🖼️ 請將圖片拖入畫面中", width / 2, height / 2);
      //   // 啟用拖曳圖片
      //   dropZone = select("canvas");
      //   dropZone.drop(gotFile);
      //   for (let i = 0; i < 150; i++) {
      //     windLines.push(new WindLine());
      //   }
      // }

      // function draw() {
      //   background(0, 20);
      //   for (let w of windLines) {
      //     w.update();
      //     w.display();
      //   }

      //   for (let p of particles) {
      //     p.update();
      //     p.display();
      //   }
      // }

      // function gotFile(file) {
      //   if (file.type === "image") {
      //     loadImage(file.data, (loaded) => {
      //       img = loaded;
      //       img.resize(200, 0);
      //       img.loadPixels();
      //       particles = [];
      //       for (let y = 0; y < img.height; y += 2) {
      //         for (let x = 0; x < img.width; x += 2) {
      //           let index = (x + y * img.width) * 4;
      //           let r = img.pixels[index];
      //           let g = img.pixels[index + 1];
      //           let b = img.pixels[index + 2];
      //           let px = x + width / 2 - img.width / 2;
      //           let py = y + height / 2 - img.height / 2;
      //           particles.push(new Particle(px, py, color(r, g, b)));
      //         }
      //       }
      //     });
      //   }
      // }

      // class Particle {
      //   constructor(x, y, col) {
      //     this.pos = createVector(x, y);
      //     this.vel = createVector(random(-0.05, 0.05), random(-0.05, 0.05));
      //     this.acc = createVector(
      //       random(-windStrength, windStrength),
      //       random(-0.00001, 0.00001)
      //     );
      //     this.decay = random(0.0001, 0.0003);
      //     this.color = col;
      //     this.alpha = 255;
      //     this.size = random(1.5, 3);
      //   }

      //   update() {
      //     this.vel.add(this.acc);
      //     this.pos.add(this.vel);
      //     this.acc.mult(this.decay);
      //     this.alpha -= 0.003;
      //   }

      //   display() {
      //     noStroke();
      //     fill(
      //       red(this.color),
      //       green(this.color),
      //       blue(this.color),
      //       this.alpha
      //     );
      //     ellipse(this.pos.x, this.pos.y, this.size);
      //   }
      // }
      // class WindLine {
      //   constructor() {
      //     this.pos = createVector(random(width), random(height));
      //     this.noiseOffset = random(1000);
      //     this.length = random(20, 80);
      //     this.alpha = random(20, 60);
      //     this.speed = random(0.3, 0.8);
      //   }

      //   update() {
      //     let angle =
      //       noise(this.pos.x * 0.001, this.pos.y * 0.001, this.noiseOffset) *
      //       TWO_PI *
      //       2;
      //     this.vel = p5.Vector.fromAngle(angle);
      //     this.pos.add(this.vel.mult(this.speed));

      //     if (
      //       this.pos.x < 0 ||
      //       this.pos.x > width ||
      //       this.pos.y < 0 ||
      //       this.pos.y > height
      //     ) {
      //       this.pos = createVector(random(width), random(height));
      //     }
      //   }

      //   display() {
      //     let next = p5.Vector.add(this.pos, this.vel.copy().mult(this.length));
      //     stroke(255, 150, 100, this.alpha);
      //     strokeWeight(0.5);
      //     line(this.pos.x, this.pos.y, next.x, next.y);
      //   }
      // }

      // function windowResized() {
      //   resizeCanvas(windowWidth, windowHeight);
      // }

      // rotate
      // let particles = [];
      // let noiseScale = 0.01;
      // let centerPoints = [];

      // function setup() {
      //   createCanvas(windowWidth, windowHeight);
      //   noStroke();
      //   for (let i = 0; i < 5000; i++) {
      //     particles.push(new Particle(random(width), random(height)));
      //   }

      //   // 噪聲塌陷點（如太陽風爆發的源頭）
      //   for (let i = 0; i < 5; i++) {
      //     centerPoints.push(createVector(random(width), random(height)));
      //   }
      // }

      // function draw() {
      //   fill(0, 15); // 半透明黑，產生記憶殘影感
      //   rect(0, 0, width, height);

      //   for (let p of particles) {
      //     p.update();
      //     p.display();
      //   }
      // }

      // class Particle {
      //   constructor(x, y) {
      //     this.pos = createVector(x, y);
      //     this.vel = p5.Vector.random2D().mult(random(0.5, 1));
      //     this.acc = createVector(0, 0);
      //     this.size = random(1, 3);
      //     this.color = color(255, random(150, 200), 0, 200);
      //   }

      //   update() {
      //     let n = noise(
      //       this.pos.x * noiseScale,
      //       this.pos.y * noiseScale,
      //       frameCount * 0.001
      //     );
      //     let angle = TAU * n;

      //     // 基於噪聲產生旋轉力場
      //     let force = p5.Vector.fromAngle(angle);
      //     force.mult(2);
      //     this.acc.add(force);

      //     // 噴射點額外的爆發力
      //     for (let center of centerPoints) {
      //       let d = dist(this.pos.x, this.pos.y, center.x, center.y);
      //       if (d < 50) {
      //         let repel = p5.Vector.sub(this.pos, center);
      //         repel.normalize().mult(2);
      //         this.acc.add(repel);
      //       }
      //     }

      //     this.vel.add(this.acc);
      //     this.vel.limit(0.2);
      //     this.pos.add(this.vel);
      //     this.acc.mult(0);

      //     // 邊界處理：如記憶穿越邊界重新回來
      //     if (this.pos.x < 0) this.pos.x = width;
      //     if (this.pos.x > width) this.pos.x = 0;
      //     if (this.pos.y < 0) this.pos.y = height;
      //     if (this.pos.y > height) this.pos.y = 0;
      //   }

      //   display() {
      //     fill(this.color);
      //     ellipse(this.pos.x, this.pos.y, this.size);
      //   }
      // }

      // 全域變數
      let particles = [];
      let attractors = [];
      const NUM_ATTRACTORS = 16; // 9 個固定的塌陷點
      let noiseScale = 0.5; // 噪聲縮放比例，控制太陽風的細膩度
      let repeller = null; // 滑鼠點擊產生的斥力點

      // 粒子 class
      class Particle {
        constructor(x, y) {
          this.pos = createVector(x, y);
          // 初始速度，可以設為隨機，讓噴射效果更自然
          this.vel = p5.Vector.random2D().mult(random(0, 2));
          this.acc = createVector(0, 0);
          this.maxSpeed = 3; // 粒子的最高速度
          this.size = random(0.5, 4); // 粒子大小
          this.lifespan = 255; // 生命值，用於淡出效果
          this.angle = random(TWO_PI);
          this.speed = random(0.01, 0.05); // 軌道旋轉速度
          this.orbitRadius = random(10, 120);
          this.orbitingPlanet = Math.floor(random(NUM_ATTRACTORS));
          this.mode = 0;
        }

        // 施加一個力
        applyForce(force) {
          this.acc.add(force);
        }

        // 更新粒子的狀態
        update() {
          this.vel.add(this.acc);
          this.vel.limit(this.maxSpeed);
          this.angle += this.speed * random(0.7);

          // 確保 orbitingPlanet 索引有效且 attractors 陣列中存在該元素及其 pos 屬性
          if (
            this.orbitingPlanet >= 0 &&
            this.orbitingPlanet < attractors.length &&
            attractors[this.orbitingPlanet] &&
            attractors[this.orbitingPlanet].pos &&
            random() > 0.03
          ) {
            let radius =
              (this.orbitRadius * attractors[this.orbitingPlanet].size) / 100;
            let x =
              radius *
                cos(
                  this.angle *
                    (attractors[this.orbitingPlanet].reverse ? -1 : 1)
                ) +
              attractors[this.orbitingPlanet].pos.x;
            let y =
              radius *
                sin(
                  this.angle *
                    (attractors[this.orbitingPlanet].reverse ? -1 : 1)
                ) +
              attractors[this.orbitingPlanet].pos.y;
            this.pos.set(x, y);

            if (random() < 0.03) {
              this.pos.add(this.vel);
            }
          } else {
            // 如果沒有有效的吸引子，則使用粒子的速度更新位置
            this.pos.add(this.vel);
            // 重新分配一個有效的吸引子
            this.orbitingPlanet = Math.floor(random(attractors.length));
          }

          this.acc.mult(0);

          // 隨著時間慢慢消逝
          if (this.lifespan > 0.5) {
            this.lifespan -= 0.5;
          }
        }

        // 顯示粒子
        display() {
          noStroke();
          // 使用 lifespan 控制透明度，營造淡出效果
          fill(255, 255, 220, this.lifespan);
          ellipse(this.pos.x, this.pos.y, this.size, this.size);
        }

        // 檢查粒子是否超出邊界
        edges() {
          if (
            this.pos.x > width ||
            this.pos.x < 0 ||
            this.pos.y > height ||
            this.pos.y < 0
          ) {
            this.lifespan = 0; // 超出邊界的粒子直接標記為死亡
          }
        }

        // 檢查粒子是否死亡
        isDead() {
          return this.lifespan <= 0;
        }
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);

        // 初始化吸引子
        for (let i = 0; i < NUM_ATTRACTORS; i++) {
          // 確保每個吸引子都有 pos 屬性
          let attractor = {
            pos: createVector(
              random(width * 0.01, width * 0.99),
              random(height * 0.01, height * 0.99)
            ),
            size: random(10, 200),
            reverse: random(1) > 0.5,
          };
          attractors.push(attractor);
        }

        // 初始生成一些粒子
        for (let i = 0; i < 200; i++) {
          particles.push(new Particle(random(width), random(height)));
        }
      }

      function draw() {
        // 使用半透明背景來製造拖影效果，形成軌跡
        background(0, 0, 10, 30);

        // 隨機決定是否從某個塌陷點噴射粒子
        if (random(1) < 0.3) {
          let attractor = random(attractors);
          if (attractor && attractor.pos) {
            for (let i = 0; i < 5; i++) {
              particles.push(new Particle(attractor.pos.x, attractor.pos.y));
            }
          }
        }

        // 遍歷所有粒子
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];

          // 1. 計算並施加「太陽風」(Perlin Noise) 的力
          let angle =
            noise(
              p.pos.x * noiseScale,
              p.pos.y * noiseScale,
              frameCount * 0.01
            ) *
            TWO_PI *
            2;
          // let noiseForce = p5.Vector.fromAngle(angle);
          // noiseForce.setMag(0.01);
          // p.applyForce(noiseForce);

          // 2. 計算並施加「重力塌陷點」的引力
          attractors.forEach((attractor) => {
            if (attractor && attractor.pos) {
              let force = p5.Vector.sub(attractor.pos, p.pos).normalize();
              let distanceSq = constrain(force.magSq(), 25, 10000);
              if (distanceSq < 1000) {
                let strength = 100 / distanceSq; // G / d^2 (G=20)
                force.setMag(strength);
                p.applyForce(force);
              }
            }
          });

          // 3. 如果存在「斥力點」(滑鼠點擊)，計算並施加斥力
          if (repeller) {
            let repelForce = p5.Vector.sub(p.pos, repeller);
            let d = repelForce.mag();
            if (d < 150) {
              // 只在 150 像素範圍內有效
              let strength = -500 / (d * d); // 斥力為負
              repelForce.setMag(strength);
              p.applyForce(repelForce);
            }
          }

          // 更新、顯示並檢查邊界
          p.update();
          p.display();
          p.edges();

          // 如果粒子死亡，就從陣列中移除
          if (p.isDead()) {
            particles.splice(i, 1);
          }
        }

        // 如果斥力點存在，繪製一個視覺效果並讓它隨時間消失
        if (repeller) {
          stroke(255, 100, 100, 100);
          noFill();
          strokeWeight(2);
          ellipse(repeller.x, repeller.y, 300, 300);
          // 讓斥力點效果短暫存在後消失
          if (frameCount % 30 === 0) {
            repeller = null;
          }
        }
      }

      // 當滑鼠按下時，創建一個斥力點，象徵「放下」的自由選擇
      function mousePressed() {
        repeller = createVector(mouseX, mouseY);
      }
    </script>
  </body>
</html>
