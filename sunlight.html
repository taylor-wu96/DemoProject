<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Solar Wind Archive｜太陽風記憶體</title>
    <script defer src="./p5.min.js"></script>
    <!-- <script defer src="./p5.sound.js"></script> -->
    <script defer src="./tone.js"></script>
    <script defer src="./soundtest.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: "Helvetica Neue", sans-serif;
      }
      #overlay {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        z-index: 10;
      }
      #overlay h1 {
        margin: 0 0 10px;
        font-size: 1.5em;
        color: #ffcc99;
      }
      #overlay p {
        font-size: 0.9em;
        color: #cccccc;
      }
    </style>
  </head>
  <body>
    <script>
      let particles = [];
      let sunPos = [];
      let maskImg;
      let lightColors = [];
      let colorIndex = 0;
      let restartSoon = false;
      let startTime;
      let isRestMode = false;
      let restStartTime;
      let changeLocation = false;
      function preload() {
        maskImg = loadImage("t03.png"); // 彩色輪廓圖
        // textureImg = loadImage("texture.jpg"); // 質感圖
      }
      function setup() {
        createCanvas(windowWidth, windowHeight);
        // 設定光源位置（可自行調整）
        for (let i = 0; i < 10; i++) {
          sunPos.push(
            createVector(
              width * random(0.25, 0.75),
              height * random(0.25, 0.75)
            )
          );
        }
        lightColors = [
          color(0, 80, 100), // deep red glow
          color(30, 90, 100), // orange-yellow dust
          color(60, 60, 100), // yellow-white sunlight
          color(120, 50, 80), // green plasma
          color(200, 70, 90), // cyan oxygen glow
          color(280, 60, 100), // purple ionized gas
          color(320, 70, 90), // magenta cosmic rays
        ];
        noStroke();
        maskImg = convertToGrayscale(maskImg);
        startTime = millis(); // record when program starts
        // maskImg.resize(windowWidth, windowHeight);
      }

      function draw() {
        // background(20, 20, 30, 25);
        blendMode(ADD);
        // 半透明深色背景，保留上一幀的光跡
        // background(20, 20, 30, 25);
        let elapsed = millis() - startTime;

        // If running for more than 3 minutes and not in rest mode
        if (!isRestMode && elapsed > 1 * 45 * 1000) {
          isRestMode = true;
          restStartTime = millis();
          changeLocation = true;
        }

        // If in rest mode and more than 20 seconds passed, reset timer
        if (isRestMode && millis() - restStartTime > 30 * 1000) {
          isRestMode = false;
          startTime = millis(); // reset main timer
        } else if (isRestMode && changeLocation) {
          sunPos = [];
          for (let i = 0; i < 10; i++) {
            sunPos.push(
              createVector(
                width * random(0.25, 0.75),
                height * random(0.25, 0.75)
              )
            );
          }
          changeLocation = false;
        }

        if (isRestMode) {
          for (let i = particles.length - 1; i >= 0; i--) {
            if (random(1) < 0.001) {
              blendMode(BURN);
            } else {
              blendMode(ADD);
            }
            const p = particles[i];
            p.update(restartSoon);
            p.show();
            if (p.isDead()) {
              particles.splice(i, 1);
            }
          }
          blendMode(BLEND);
          let scale = min(
            windowWidth / maskImg.width,
            windowHeight / maskImg.height
          );
          let imgW = maskImg.width * scale;
          let imgH = maskImg.height * scale;
          let x = (windowWidth - imgW) / 2;
          let y = (windowHeight - imgH) / 2;

          image(maskImg, x, y, imgW, imgH);
          push();
          fill(0, 0, 0);
          rect(0, 0, (windowWidth - imgW) / 2, windowHeight);
          rect(
            (windowWidth + imgW) / 2,
            0,
            (windowWidth + imgW) / 2,
            windowHeight
          );
          pop();
          return;
        }

        // 啟用加色 (ADD) 混合模式，增強光暈

        if (frameCount % 600 === 0) {
          colorIndex = (colorIndex + 1) % lightColors.length;
          console.log(colorIndex);
        }

        // 每幀產生少量新粒子
        if (frameCount > 60 * 10) {
          let counts = frameCount - 60 * 10;
          // let counts = 5000;
          let genParticles = min(counts / 10 + 1, 80);
          for (let i = 0; i < genParticles; i++) {
            particles.push(new SunParticle());
          }
          // 更新並繪製
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.update(restartSoon);
            p.show();
            if (p.isDead()) {
              particles.splice(i, 1);
            }
          }
          if (random(1) < 0.001) {
            restartSoon = true;
            // particles = [];
          } else {
            restartSoon = false;
          }
        }

        // 回到預設混合模式
        blendMode(BLEND);
        let scale = min(
          windowWidth / maskImg.width,
          windowHeight / maskImg.height
        );
        let imgW = maskImg.width * scale;
        let imgH = maskImg.height * scale;
        let x = (windowWidth - imgW) / 2;
        let y = (windowHeight - imgH) / 2;

        image(maskImg, x, y, imgW, imgH);
        push();
        fill(0, 0, 0);
        rect(0, 0, (windowWidth - imgW) / 2, windowHeight);
        rect(
          (windowWidth + imgW) / 2,
          0,
          (windowWidth + imgW) / 2,
          windowHeight
        );
        pop();
        // image(
        //   (4 * maskImg) / 5,
        //   (windowWidth - maskImg.width) / 2,
        //   (windowHeight - maskImg.height) / 2
        // );
      }

      // ------ 粒子類別 ------
      class SunParticle {
        constructor() {
          // 從光源附近隨機一點產生
          this.pos = sunPos[floor(random(0, sunPos.length))]
            .copy()
            .add(random(-20, 20), random(-20, 20));
          // 大致往下斜右的角度，加上一點隨機範圍
          const baseAngle = PI * 0.7;
          this.angle = random(baseAngle - PI, baseAngle + PI);
          this.speed = random(0.05, 0.6);
          this.vel = p5.Vector.fromAngle(this.angle).mult(this.speed);
          this.lifespan = random(200, 800);
          this.size = random(0.1, 2);
          this.noiseOffset = random(100);
        }

        update(isDeadSoon) {
          // 加入噪聲微抖
          const n = noise(this.noiseOffset, frameCount * 0.01) - 0.5;
          this.vel.rotate(n * random(0.01, 0.1));
          this.pos.add(this.vel);
          if (isDeadSoon && this.lifespan > 10 && random(1) < 0.5) {
            this.lifespan = floor(random(10));
          } else {
            if (random(1) < 0.001) {
              this.lifespan = 1;
            }
            this.lifespan--;
          }
        }

        show() {
          // 生命結束時慢慢消失
          const alpha = map(this.lifespan, 0, 120, 0, 200);
          push();
          colorMode(HSB);
          fill(lightColors[colorIndex], alpha);
          ellipse(this.pos.x, this.pos.y, this.size);
          pop();
        }

        isDead() {
          return this.lifespan <= 0;
        }
      }

      function convertToGrayscale(srcImg) {
        let grayImg = createImage(srcImg.width, srcImg.height);
        console.log(srcImg.width, srcImg.height);
        srcImg.loadPixels();
        grayImg.loadPixels();

        for (let i = 0; i < srcImg.pixels.length; i += 4) {
          let r = srcImg.pixels[i];
          let g = srcImg.pixels[i + 1];
          let b = srcImg.pixels[i + 2];
          // 計算亮度值 (加權平均法)
          let brightness = 0.299 * r + 0.587 * g + 0.114 * b;

          // 對比增強：加深白黑差異
          // brightness = brightness > 128 ? 0 : 255;
          let minBrightness = max(200 - brightness, 0);
          grayImg.pixels[i] = (brightness + 0.6 * r) / 6;
          grayImg.pixels[i + 1] = (brightness + 0.6 * g) / 6;
          grayImg.pixels[i + 2] = (brightness + 0.6 * b) / 6;
          grayImg.pixels[i + 3] = map(minBrightness, 0, 200, 2, 255);
        }

        grayImg.updatePixels();
        return grayImg;
      }

      // 自動對齊視窗大小
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
      window.addEventListener("click", () => {
        if (!isPlaying) {
          startMusic();
          isPlaying = true;
        }
      });
    </script>
  </body>
</html>
