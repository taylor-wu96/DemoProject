<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Solar Wind Archive｜太陽風記憶體</title>
    <script src="./p5.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: "Helvetica Neue", sans-serif;
      }
      #overlay {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        z-index: 10;
      }
      #overlay h1 {
        margin: 0 0 10px;
        font-size: 1.5em;
        color: #ffcc99;
      }
      #overlay p {
        font-size: 0.9em;
        color: #cccccc;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>太陽風記憶體｜Solar Wind Archive</h1>
      <p>🖼️ 請將你的圖像拖曳進畫面<br />在日冕風中，記憶將被釋放</p>
    </div>

    <script>
      let img, vid, gfx;
      let particles = [];
      let windStrength = 0.005;
      let imgSize = 200;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        pixelDensity(1);
        imageMode(CENTER);
        background(0);
        textAlign(CENTER);
        textSize(16);
        fill(255);
        text("🖼️ / 🎥 請將圖片或影片拖入畫面中", width / 2, height / 2);

        gfx = createGraphics(imgSize, imgSize);
        dropZone = select("canvas");
        dropZone.drop(gotFile);
      }

      function draw() {
        background(0, 20);

        // 先把當前影像（img 或 vid）畫到 gfx，再 loadPixels
        if (img || vid) {
          gfx.clear();
          if (img) {
            gfx.image(img, gfx.width / 2, gfx.height / 2);
          } else if (vid && vid.loadedmetadata) {
            gfx.image(
              vid,
              gfx.width / 2,
              gfx.height / 2,
              gfx.width,
              gfx.height
            );
          }
          gfx.loadPixels();
          // 重新生成 particles（也可以改成只一次生成，這裡示範每幀都更新顏色）
          let idx = 0;
          for (let y = 0; y < gfx.height; y += 2) {
            for (let x = 0; x < gfx.width; x += 2) {
              let i = (x + y * gfx.width) * 4;
              let c = color(
                gfx.pixels[i],
                gfx.pixels[i + 1],
                gfx.pixels[i + 2]
              );
              // 如果已經有這個 particle，就更新顏色；沒有就 push 新的
              if (particles[idx]) {
                particles[idx].color = c;
              } else {
                let px = x + width / 2 - gfx.width / 2;
                let py = y + height / 2 - gfx.height / 2;
                particles.push(new Particle(px, py, c));
              }
              idx++;
            }
          }
          // 如果多餘，就刪掉
          particles.splice(idx);
        }

        // 更新、繪製
        for (let p of particles) {
          p.update();
          p.display();
        }
      }

      function gotFile(file) {
        // 先清掉舊的
        img = vid = null;
        particles = [];

        if (file.type === "image") {
          loadImage(file.data, (loaded) => {
            img = loaded;
            img.resize(200, 0);
          });
        } else if (file.type === "video") {
          vid = createVideo([file.data], () => {
            vid.loop();
            vid.volume(1);
            vid.hide();
            // 確保 gfx 大小配合影片
            if (vid.width > vid.height) {
              vid.size(imgSize, vid.height * (imgSize / vid.width));
            } else {
              vid.size(vid.width * (imgSize / vid.height), imgSize);
            }
            gfx.resizeCanvas(vid.width, vid.height);
          });
        }
      }

      class Particle {
        constructor(x, y, col) {
          this.pos = createVector(x, y);
          this.vel = createVector(random(-0.05, 0.05), random(-0.05, 0.05));
          this.acc = createVector(
            random(-windStrength, windStrength),
            random(-0.00001, 0.00001)
          );
          this.decay = random(0.0001, 0.0003);
          this.color = col;
          this.alpha = 255;
          this.size = random(1.5, 3);
        }
        update() {
          this.vel.add(this.acc);
          this.pos.add(this.vel);
          this.acc.mult(this.decay);
          this.alpha -= 0.003;
        }
        display() {
          noStroke();
          fill(
            red(this.color),
            green(this.color),
            blue(this.color),
            this.alpha
          );
          ellipse(this.pos.x, this.pos.y, this.size);
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }

      // // 全域變數
      // let particles = [];
      // let attractors = [];
      // const NUM_ATTRACTORS = 8; // 9 個固定的塌陷點
      // let noiseScale = 0.5; // 噪聲縮放比例，控制太陽風的細膩度
      // let repeller = null; // 滑鼠點擊產生的斥力點

      // // 粒子 class
      // class Particle {
      //   constructor(x, y) {
      //     this.pos = createVector(x, y);
      //     // 初始速度，可以設為隨機，讓噴射效果更自然
      //     this.vel = p5.Vector.random2D().mult(random(0, 2));
      //     this.acc = createVector(0, 0);
      //     this.maxSpeed = 3; // 粒子的最高速度
      //     this.size = random(0.5, 4); // 粒子大小
      //     this.lifespan = 255; // 生命值，用於淡出效果
      //     this.angle = random(TWO_PI);
      //     this.speed = random(0.01, 0.05); // 軌道旋轉速度
      //     this.orbitRadius = random(10, 120);
      //     this.orbitingPlanet = Math.floor(random(NUM_ATTRACTORS));
      //     this.mode = 0;
      //   }

      //   // 施加一個力
      //   applyForce(force) {
      //     this.acc.add(force);
      //   }

      //   // 更新粒子的狀態
      //   update() {
      //     this.vel.add(this.acc);
      //     this.vel.limit(this.maxSpeed);
      //     // 確保 orbitingPlanet 索引有效且 attractors 陣列中存在該元素及其 pos 屬性
      //     if (
      //       this.orbitingPlanet >= 0 &&
      //       this.orbitingPlanet < attractors.length &&
      //       attractors[this.orbitingPlanet] &&
      //       attractors[this.orbitingPlanet].pos &&
      //       random() > 0.03
      //     ) {
      //       this.angle +=
      //         this.speed *
      //         attractors[this.orbitingPlanet].speedFactor *
      //         random(0.1, 0.7);
      //       let radius =
      //         (this.orbitRadius * attractors[this.orbitingPlanet].size) / 100;
      //       let x =
      //         radius *
      //           cos(
      //             this.angle *
      //               (attractors[this.orbitingPlanet].reverse ? -1 : 1)
      //           ) +
      //         attractors[this.orbitingPlanet].pos.x;
      //       let y =
      //         radius *
      //           sin(
      //             this.angle *
      //               (attractors[this.orbitingPlanet].reverse ? -1 : 1)
      //           ) +
      //         attractors[this.orbitingPlanet].pos.y;
      //       this.pos.set(x, y);

      //       if (random() < 0.03) {
      //         this.pos.add(this.vel);
      //       }
      //     } else {
      //       // 如果沒有有效的吸引子，則使用粒子的速度更新位置
      //       this.pos.add(this.vel);
      //       // 重新分配一個有效的吸引子
      //       this.orbitingPlanet = Math.floor(random(attractors.length));
      //     }

      //     this.acc.mult(0);

      //     // 隨著時間慢慢消逝
      //     if (this.lifespan > 0.5) {
      //       this.lifespan -= 0.5;
      //     }
      //   }

      //   // 顯示粒子
      //   display() {
      //     noStroke();
      //     // 使用 lifespan 控制透明度，營造淡出效果
      //     fill(255, 255, 220, this.lifespan);
      //     ellipse(this.pos.x, this.pos.y, this.size, this.size);
      //   }

      //   // 檢查粒子是否超出邊界
      //   edges() {
      //     if (
      //       this.pos.x > width ||
      //       this.pos.x < 0 ||
      //       this.pos.y > height ||
      //       this.pos.y < 0
      //     ) {
      //       this.lifespan = 0; // 超出邊界的粒子直接標記為死亡
      //     }
      //   }

      //   // 檢查粒子是否死亡
      //   isDead() {
      //     return this.lifespan <= 0;
      //   }
      // }

      // function setup() {
      //   createCanvas(windowWidth, windowHeight);

      //   // 初始化吸引子
      //   for (let i = 0; i < NUM_ATTRACTORS; i++) {
      //     // 確保每個吸引子都有 pos 屬性
      //     let attractor = {
      //       pos: createVector(
      //         random(width * 0.01, width * 0.99),
      //         random(height * 0.01, height * 0.99)
      //       ),
      //       size: random(10, 200),
      //       reverse: random(1) > 0.5,
      //       speedFactor: random(0.1, 1.2),
      //     };
      //     attractors.push(attractor);
      //   }

      //   // 初始生成一些粒子
      //   for (let i = 0; i < 200; i++) {
      //     particles.push(new Particle(random(width), random(height)));
      //   }
      // }

      // function draw() {
      //   // 使用半透明背景來製造拖影效果，形成軌跡
      //   background(0, 0, 10, 30);

      //   // 隨機決定是否從某個塌陷點噴射粒子
      //   if (random(1) < 0.3) {
      //     let attractor = random(attractors);
      //     if (attractor && attractor.pos) {
      //       for (let i = 0; i < 5; i++) {
      //         particles.push(new Particle(attractor.pos.x, attractor.pos.y));
      //       }
      //     }
      //   }

      //   // 遍歷所有粒子
      //   for (let i = particles.length - 1; i >= 0; i--) {
      //     let p = particles[i];

      //     // 1. 計算並施加「太陽風」(Perlin Noise) 的力
      //     let angle =
      //       noise(
      //         p.pos.x * noiseScale,
      //         p.pos.y * noiseScale,
      //         frameCount * 0.01
      //       ) *
      //       TWO_PI *
      //       2;
      //     // let noiseForce = p5.Vector.fromAngle(angle);
      //     // noiseForce.setMag(0.01);
      //     // p.applyForce(noiseForce);

      //     // 2. 計算並施加「重力塌陷點」的引力
      //     attractors.forEach((attractor) => {
      //       if (attractor && attractor.pos) {
      //         let force = p5.Vector.sub(attractor.pos, p.pos).normalize();
      //         let distanceSq = constrain(force.magSq(), 25, 10000);
      //         if (distanceSq < 1000) {
      //           let strength = 100 / distanceSq; // G / d^2 (G=20)
      //           force.setMag(strength);
      //           p.applyForce(force);
      //         }
      //       }
      //     });

      //     // 3. 如果存在「斥力點」(滑鼠點擊)，計算並施加斥力
      //     if (repeller) {
      //       let repelForce = p5.Vector.sub(p.pos, repeller);
      //       let d = repelForce.mag();
      //       if (d < 150) {
      //         // 只在 150 像素範圍內有效
      //         let strength = -500 / (d * d); // 斥力為負
      //         repelForce.setMag(strength);
      //         p.applyForce(repelForce);
      //       }
      //     }

      //     // 更新、顯示並檢查邊界
      //     p.update();
      //     p.display();
      //     p.edges();

      //     // 如果粒子死亡，就從陣列中移除
      //     if (p.isDead()) {
      //       particles.splice(i, 1);
      //     }
      //   }

      //   // 如果斥力點存在，繪製一個視覺效果並讓它隨時間消失
      //   if (repeller) {
      //     stroke(255, 100, 100, 100);
      //     noFill();
      //     strokeWeight(2);
      //     ellipse(repeller.x, repeller.y, 300, 300);
      //     // 讓斥力點效果短暫存在後消失
      //     if (frameCount % 30 === 0) {
      //       repeller = null;
      //     }
      //   }
      // }

      // // 當滑鼠按下時，創建一個斥力點，象徵「放下」的自由選擇
      // function mousePressed() {
      //   repeller = createVector(mouseX, mouseY);
      // }
    </script>
  </body>
</html>
