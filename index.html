<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Solar Wind Archiveï½œå¤ªé™½é¢¨è¨˜æ†¶é«”</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: "Helvetica Neue", sans-serif;
      }
      #overlay {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        z-index: 10;
      }
      #overlay h1 {
        margin: 0 0 10px;
        font-size: 1.5em;
        color: #ffcc99;
      }
      #overlay p {
        font-size: 0.9em;
        color: #cccccc;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>å¤ªé™½é¢¨è¨˜æ†¶é«”ï½œSolar Wind Archive</h1>
      <p>ğŸ–¼ï¸ è«‹å°‡ä½ çš„åœ–åƒæ‹–æ›³é€²ç•«é¢<br />åœ¨æ—¥å†•é¢¨ä¸­ï¼Œè¨˜æ†¶å°‡è¢«é‡‹æ”¾</p>
    </div>

    <script>
      // let img;
      // let particles = [];
      // let windLines = [];
      // let windStrength = 0.005;

      // function setup() {
      //   createCanvas(windowWidth, windowHeight);
      //   pixelDensity(1);
      //   imageMode(CENTER);
      //   background(0);
      //   textAlign(CENTER);
      //   textSize(16);
      //   fill(255);
      //   text("ğŸ–¼ï¸ è«‹å°‡åœ–ç‰‡æ‹–å…¥ç•«é¢ä¸­", width / 2, height / 2);
      //   // å•Ÿç”¨æ‹–æ›³åœ–ç‰‡
      //   dropZone = select("canvas");
      //   dropZone.drop(gotFile);
      //   for (let i = 0; i < 150; i++) {
      //     windLines.push(new WindLine());
      //   }
      // }

      // function draw() {
      //   background(0, 20);
      //   for (let w of windLines) {
      //     w.update();
      //     w.display();
      //   }

      //   for (let p of particles) {
      //     p.update();
      //     p.display();
      //   }
      // }

      // function gotFile(file) {
      //   if (file.type === "image") {
      //     loadImage(file.data, (loaded) => {
      //       img = loaded;
      //       img.resize(200, 0);
      //       img.loadPixels();
      //       particles = [];
      //       for (let y = 0; y < img.height; y += 2) {
      //         for (let x = 0; x < img.width; x += 2) {
      //           let index = (x + y * img.width) * 4;
      //           let r = img.pixels[index];
      //           let g = img.pixels[index + 1];
      //           let b = img.pixels[index + 2];
      //           let px = x + width / 2 - img.width / 2;
      //           let py = y + height / 2 - img.height / 2;
      //           particles.push(new Particle(px, py, color(r, g, b)));
      //         }
      //       }
      //     });
      //   }
      // }

      // class Particle {
      //   constructor(x, y, col) {
      //     this.pos = createVector(x, y);
      //     this.vel = createVector(random(-0.05, 0.05), random(-0.05, 0.05));
      //     this.acc = createVector(
      //       random(-windStrength, windStrength),
      //       random(-0.00001, 0.00001)
      //     );
      //     this.decay = random(0.0001, 0.0003);
      //     this.color = col;
      //     this.alpha = 255;
      //     this.size = random(1.5, 3);
      //   }

      //   update() {
      //     this.vel.add(this.acc);
      //     this.pos.add(this.vel);
      //     this.acc.mult(this.decay);
      //     this.alpha -= 0.003;
      //   }

      //   display() {
      //     noStroke();
      //     fill(
      //       red(this.color),
      //       green(this.color),
      //       blue(this.color),
      //       this.alpha
      //     );
      //     ellipse(this.pos.x, this.pos.y, this.size);
      //   }
      // }
      // class WindLine {
      //   constructor() {
      //     this.pos = createVector(random(width), random(height));
      //     this.noiseOffset = random(1000);
      //     this.length = random(20, 80);
      //     this.alpha = random(20, 60);
      //     this.speed = random(0.3, 0.8);
      //   }

      //   update() {
      //     let angle =
      //       noise(this.pos.x * 0.001, this.pos.y * 0.001, this.noiseOffset) *
      //       TWO_PI *
      //       2;
      //     this.vel = p5.Vector.fromAngle(angle);
      //     this.pos.add(this.vel.mult(this.speed));

      //     if (
      //       this.pos.x < 0 ||
      //       this.pos.x > width ||
      //       this.pos.y < 0 ||
      //       this.pos.y > height
      //     ) {
      //       this.pos = createVector(random(width), random(height));
      //     }
      //   }

      //   display() {
      //     let next = p5.Vector.add(this.pos, this.vel.copy().mult(this.length));
      //     stroke(255, 150, 100, this.alpha);
      //     strokeWeight(0.5);
      //     line(this.pos.x, this.pos.y, next.x, next.y);
      //   }
      // }

      // function windowResized() {
      //   resizeCanvas(windowWidth, windowHeight);
      // }

      // rotate
      // let particles = [];
      // let noiseScale = 0.01;
      // let centerPoints = [];

      // function setup() {
      //   createCanvas(windowWidth, windowHeight);
      //   noStroke();
      //   for (let i = 0; i < 5000; i++) {
      //     particles.push(new Particle(random(width), random(height)));
      //   }

      //   // å™ªè²å¡Œé™·é»ï¼ˆå¦‚å¤ªé™½é¢¨çˆ†ç™¼çš„æºé ­ï¼‰
      //   for (let i = 0; i < 5; i++) {
      //     centerPoints.push(createVector(random(width), random(height)));
      //   }
      // }

      // function draw() {
      //   fill(0, 15); // åŠé€æ˜é»‘ï¼Œç”¢ç”Ÿè¨˜æ†¶æ®˜å½±æ„Ÿ
      //   rect(0, 0, width, height);

      //   for (let p of particles) {
      //     p.update();
      //     p.display();
      //   }
      // }

      // class Particle {
      //   constructor(x, y) {
      //     this.pos = createVector(x, y);
      //     this.vel = p5.Vector.random2D().mult(random(0.5, 1));
      //     this.acc = createVector(0, 0);
      //     this.size = random(1, 3);
      //     this.color = color(255, random(150, 200), 0, 200);
      //   }

      //   update() {
      //     let n = noise(
      //       this.pos.x * noiseScale,
      //       this.pos.y * noiseScale,
      //       frameCount * 0.001
      //     );
      //     let angle = TAU * n;

      //     // åŸºæ–¼å™ªè²ç”¢ç”Ÿæ—‹è½‰åŠ›å ´
      //     let force = p5.Vector.fromAngle(angle);
      //     force.mult(2);
      //     this.acc.add(force);

      //     // å™´å°„é»é¡å¤–çš„çˆ†ç™¼åŠ›
      //     for (let center of centerPoints) {
      //       let d = dist(this.pos.x, this.pos.y, center.x, center.y);
      //       if (d < 50) {
      //         let repel = p5.Vector.sub(this.pos, center);
      //         repel.normalize().mult(2);
      //         this.acc.add(repel);
      //       }
      //     }

      //     this.vel.add(this.acc);
      //     this.vel.limit(0.2);
      //     this.pos.add(this.vel);
      //     this.acc.mult(0);

      //     // é‚Šç•Œè™•ç†ï¼šå¦‚è¨˜æ†¶ç©¿è¶Šé‚Šç•Œé‡æ–°å›ä¾†
      //     if (this.pos.x < 0) this.pos.x = width;
      //     if (this.pos.x > width) this.pos.x = 0;
      //     if (this.pos.y < 0) this.pos.y = height;
      //     if (this.pos.y > height) this.pos.y = 0;
      //   }

      //   display() {
      //     fill(this.color);
      //     ellipse(this.pos.x, this.pos.y, this.size);
      //   }
      // }

      // å…¨åŸŸè®Šæ•¸
      let particles = [];
      let attractors = [];
      const NUM_ATTRACTORS = 16; // 9 å€‹å›ºå®šçš„å¡Œé™·é»
      let noiseScale = 0.5; // å™ªè²ç¸®æ”¾æ¯”ä¾‹ï¼Œæ§åˆ¶å¤ªé™½é¢¨çš„ç´°è†©åº¦
      let repeller = null; // æ»‘é¼ é»æ“Šç”¢ç”Ÿçš„æ–¥åŠ›é»

      // ç²’å­ class
      class Particle {
        constructor(x, y) {
          this.pos = createVector(x, y);
          // åˆå§‹é€Ÿåº¦ï¼Œå¯ä»¥è¨­ç‚ºéš¨æ©Ÿï¼Œè®“å™´å°„æ•ˆæœæ›´è‡ªç„¶
          this.vel = p5.Vector.random2D().mult(random(0, 2));
          this.acc = createVector(0, 0);
          this.maxSpeed = 3; // ç²’å­çš„æœ€é«˜é€Ÿåº¦
          this.size = random(0.5, 4); // ç²’å­å¤§å°
          this.lifespan = 255; // ç”Ÿå‘½å€¼ï¼Œç”¨æ–¼æ·¡å‡ºæ•ˆæœ
          this.angle = random(TWO_PI);
          this.speed = random(0.01, 0.05); // è»Œé“æ—‹è½‰é€Ÿåº¦
          this.orbitRadius = random(10, 120);
          this.orbitingPlanet = Math.floor(random(NUM_ATTRACTORS));
          this.mode = 0;
        }

        // æ–½åŠ ä¸€å€‹åŠ›
        applyForce(force) {
          this.acc.add(force);
        }

        // æ›´æ–°ç²’å­çš„ç‹€æ…‹
        update() {
          this.vel.add(this.acc);
          this.vel.limit(this.maxSpeed);
          this.angle += this.speed * random(0.7);

          // ç¢ºä¿ orbitingPlanet ç´¢å¼•æœ‰æ•ˆä¸” attractors é™£åˆ—ä¸­å­˜åœ¨è©²å…ƒç´ åŠå…¶ pos å±¬æ€§
          if (
            this.orbitingPlanet >= 0 &&
            this.orbitingPlanet < attractors.length &&
            attractors[this.orbitingPlanet] &&
            attractors[this.orbitingPlanet].pos &&
            random() > 0.03
          ) {
            let radius =
              (this.orbitRadius * attractors[this.orbitingPlanet].size) / 100;
            let x =
              radius *
                cos(
                  this.angle *
                    (attractors[this.orbitingPlanet].reverse ? -1 : 1)
                ) +
              attractors[this.orbitingPlanet].pos.x;
            let y =
              radius *
                sin(
                  this.angle *
                    (attractors[this.orbitingPlanet].reverse ? -1 : 1)
                ) +
              attractors[this.orbitingPlanet].pos.y;
            this.pos.set(x, y);

            if (random() < 0.03) {
              this.pos.add(this.vel);
            }
          } else {
            // å¦‚æœæ²’æœ‰æœ‰æ•ˆçš„å¸å¼•å­ï¼Œå‰‡ä½¿ç”¨ç²’å­çš„é€Ÿåº¦æ›´æ–°ä½ç½®
            this.pos.add(this.vel);
            // é‡æ–°åˆ†é…ä¸€å€‹æœ‰æ•ˆçš„å¸å¼•å­
            this.orbitingPlanet = Math.floor(random(attractors.length));
          }

          this.acc.mult(0);

          // éš¨è‘—æ™‚é–“æ…¢æ…¢æ¶ˆé€
          if (this.lifespan > 0.5) {
            this.lifespan -= 0.5;
          }
        }

        // é¡¯ç¤ºç²’å­
        display() {
          noStroke();
          // ä½¿ç”¨ lifespan æ§åˆ¶é€æ˜åº¦ï¼Œç‡Ÿé€ æ·¡å‡ºæ•ˆæœ
          fill(255, 255, 220, this.lifespan);
          ellipse(this.pos.x, this.pos.y, this.size, this.size);
        }

        // æª¢æŸ¥ç²’å­æ˜¯å¦è¶…å‡ºé‚Šç•Œ
        edges() {
          if (
            this.pos.x > width ||
            this.pos.x < 0 ||
            this.pos.y > height ||
            this.pos.y < 0
          ) {
            this.lifespan = 0; // è¶…å‡ºé‚Šç•Œçš„ç²’å­ç›´æ¥æ¨™è¨˜ç‚ºæ­»äº¡
          }
        }

        // æª¢æŸ¥ç²’å­æ˜¯å¦æ­»äº¡
        isDead() {
          return this.lifespan <= 0;
        }
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);

        // åˆå§‹åŒ–å¸å¼•å­
        for (let i = 0; i < NUM_ATTRACTORS; i++) {
          // ç¢ºä¿æ¯å€‹å¸å¼•å­éƒ½æœ‰ pos å±¬æ€§
          let attractor = {
            pos: createVector(
              random(width * 0.01, width * 0.99),
              random(height * 0.01, height * 0.99)
            ),
            size: random(10, 200),
            reverse: random(1) > 0.5,
          };
          attractors.push(attractor);
        }

        // åˆå§‹ç”Ÿæˆä¸€äº›ç²’å­
        for (let i = 0; i < 200; i++) {
          particles.push(new Particle(random(width), random(height)));
        }
      }

      function draw() {
        // ä½¿ç”¨åŠé€æ˜èƒŒæ™¯ä¾†è£½é€ æ‹–å½±æ•ˆæœï¼Œå½¢æˆè»Œè·¡
        background(0, 0, 10, 30);

        // éš¨æ©Ÿæ±ºå®šæ˜¯å¦å¾æŸå€‹å¡Œé™·é»å™´å°„ç²’å­
        if (random(1) < 0.3) {
          let attractor = random(attractors);
          if (attractor && attractor.pos) {
            for (let i = 0; i < 5; i++) {
              particles.push(new Particle(attractor.pos.x, attractor.pos.y));
            }
          }
        }

        // éæ­·æ‰€æœ‰ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];

          // 1. è¨ˆç®—ä¸¦æ–½åŠ ã€Œå¤ªé™½é¢¨ã€(Perlin Noise) çš„åŠ›
          let angle =
            noise(
              p.pos.x * noiseScale,
              p.pos.y * noiseScale,
              frameCount * 0.01
            ) *
            TWO_PI *
            2;
          // let noiseForce = p5.Vector.fromAngle(angle);
          // noiseForce.setMag(0.01);
          // p.applyForce(noiseForce);

          // 2. è¨ˆç®—ä¸¦æ–½åŠ ã€Œé‡åŠ›å¡Œé™·é»ã€çš„å¼•åŠ›
          attractors.forEach((attractor) => {
            if (attractor && attractor.pos) {
              let force = p5.Vector.sub(attractor.pos, p.pos).normalize();
              let distanceSq = constrain(force.magSq(), 25, 10000);
              if (distanceSq < 1000) {
                let strength = 100 / distanceSq; // G / d^2 (G=20)
                force.setMag(strength);
                p.applyForce(force);
              }
            }
          });

          // 3. å¦‚æœå­˜åœ¨ã€Œæ–¥åŠ›é»ã€(æ»‘é¼ é»æ“Š)ï¼Œè¨ˆç®—ä¸¦æ–½åŠ æ–¥åŠ›
          if (repeller) {
            let repelForce = p5.Vector.sub(p.pos, repeller);
            let d = repelForce.mag();
            if (d < 150) {
              // åªåœ¨ 150 åƒç´ ç¯„åœå…§æœ‰æ•ˆ
              let strength = -500 / (d * d); // æ–¥åŠ›ç‚ºè² 
              repelForce.setMag(strength);
              p.applyForce(repelForce);
            }
          }

          // æ›´æ–°ã€é¡¯ç¤ºä¸¦æª¢æŸ¥é‚Šç•Œ
          p.update();
          p.display();
          p.edges();

          // å¦‚æœç²’å­æ­»äº¡ï¼Œå°±å¾é™£åˆ—ä¸­ç§»é™¤
          if (p.isDead()) {
            particles.splice(i, 1);
          }
        }

        // å¦‚æœæ–¥åŠ›é»å­˜åœ¨ï¼Œç¹ªè£½ä¸€å€‹è¦–è¦ºæ•ˆæœä¸¦è®“å®ƒéš¨æ™‚é–“æ¶ˆå¤±
        if (repeller) {
          stroke(255, 100, 100, 100);
          noFill();
          strokeWeight(2);
          ellipse(repeller.x, repeller.y, 300, 300);
          // è®“æ–¥åŠ›é»æ•ˆæœçŸ­æš«å­˜åœ¨å¾Œæ¶ˆå¤±
          if (frameCount % 30 === 0) {
            repeller = null;
          }
        }
      }

      // ç•¶æ»‘é¼ æŒ‰ä¸‹æ™‚ï¼Œå‰µå»ºä¸€å€‹æ–¥åŠ›é»ï¼Œè±¡å¾µã€Œæ”¾ä¸‹ã€çš„è‡ªç”±é¸æ“‡
      function mousePressed() {
        repeller = createVector(mouseX, mouseY);
      }
    </script>
  </body>
</html>
